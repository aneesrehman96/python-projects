# -*- coding: utf-8 -*-
"""Optimizing Resource Allocations - Python.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1b9UpVDUZ-5Ix0baQF7IMpnED-1e7qWEL
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline
from pylab import * # for graphing

import shutil
import sys
import os.path

if not shutil.which("pyomo"):
    !pip install -q pyomo
    assert(shutil.which("pyomo"))

if not (shutil.which("cbc") or os.path.isfile("cbc")):
    if "google.colab" in sys.modules:
        !apt-get install -y -qq coinor-cbc
    else:
        try:
            !conda install -c conda-forge coincbc
        except:
            pass

assert(shutil.which("cbc") or os.path.isfile("cbc"))

from pyomo.environ import *
import numpy as np
import pandas as pd

"""# Problem 1

Solve the following problem using the graphical method.

$Min(Z) = 4X + 7Y$

subject to:
* $2X + 3Y \geq 60$
* $4X + 2Y \geq 80$
* $X \leq 24$
* $X,Y \geq 0$ (nonnegativity)
"""

figure(figsize=(6,6))
#subplot(111, aspect='equal')
axis([0,50,0,50])
xlabel('X')
ylabel('Y')

# Constraint 1
y = array([20, 0])
x = array([0,30])
plot(x,y,'red',lw=2)
fill_between([0,30], # x area
             [0,0], # y area
             [20,0], # upper area
             color='red', # color
             alpha=0.15) # transparency

# Constraint 2
y = array([40, 0])
x = array([0,20])
plot(x,y,'orange',lw=2)
fill_between([0,20], # x area
             [0,0], # y area
             [40,0], # upper area
             color='orange', # color
             alpha=0.15) # transparency

# Constraint 3
y = array([0, 50])
x = array([24,24])
plot(x,y,'green',lw=2)
fill_between([24,50], # x area
             [0,0], # y area
             [50,50], # upper area
             color='green', # color
             alpha=0.15) # transparency

legend(['Constraint 1','Constraint 2','Constraint 3'])

# y axis and orange
A = np.array([[1, 0], [4, 2]])
B = np.array([0, 80])
point_1 = np.linalg.solve(A,B)
print("Point 1: ", point_1)

# red and orange
A = np.array([[2, 3], [4, 2]])
B = np.array([60, 80])
point_2 = np.linalg.solve(A,B)
print("Point 2: ", point_2)

#red and green
A = np.array([[2, 3], [1, 0]])
B = np.array([60, 24])
point_3 = np.linalg.solve(A,B)
print("Point 3: ", point_3)

print(4*point_1[0] + 7*point_1[1])
print(4*point_2[0] + 7*point_2[1])
print(4*point_3[0] + 7*point_3[1])

"""Point 3: [24, 4] is an optimal solution with optimal value 124

# Problem 2

Formulate the dual of Problem 1.  Can you find a feasible solution that proves that the solution from Problem 1 that you found is optimal?

$Min(Z) = 4X + 7Y$

subject to:
* $2X + 3Y \geq 60$
* $4X + 2Y \geq 80$
* $X \leq 24$
* $X,Y \geq 0$ (nonnegativity)

TRANSFORM
* $2X + 3Y \geq 60$
* $4X + 2Y \geq 80$
* -$X \geq -24$
* $X,Y \geq 0$ (nonnegativity)

This is the dual. I formulate this by having a new variable for each constraint, and the objective function becomes the right hand side of the equations mutliplied by the variables, and the constraints ensure that I find a combination that is better than the objective function.

$\max 60 z_1 + 80 z_2 - 24 z_3$

Subject to

* $2 z_1 + 4 z_2 - 1 z_3 \leq 4$
* $3 z_1 + 2 z_2  \leq 7$
* $z_1, z_2, z_3 \geq 0$

(1,0,0) is a feasible solution.

Plugging this into the objective, we get:

60 * 1 + 80 * 0 - 24 * 0 = 60

Therefore, the optimal value can be no less than 60

($2 z_1 + 4 z_2 - 1 z_3 \leq 4$) * 15


$30 z_1 + 60 z_2 - 15 z_3 \leq 60$

Therefore, any feasible solution to the dual has to satisfy the following:

$30 z_1 + 60 z_2 - 15 z_3 \leq 60$

If I think about it:

 $60 z_1 + 80 z_2 - 24 z_3$ $\leq$ $30 z_1 + 60 z_2 - 15 z_3 \leq 60$

I then know:

 $60 z_1 + 80 z_2 - 24 z_3$ $ \leq 60$

# Problem 3

David Petroleum (DP) is preparing to ship gasoline to gas stations for sale to customers.  DP is known to sell gas with an *octane rating* of at least 87 and a *viscosity index* of at least 31.5.  These are two measures which give customers an indication of how good the gas they are purchasing is, and so they do not want to sell gas with less than this quality in either measure.

In order to create the gas that they sell, DP blends three crude gasoline stock products.  Each of the three stocks has a particular octane rating and viscosity index:

* Crude stock 1: Octane rating = 80, Viscosity index = 30
* Crude stock 2: Octane rating = 85, Viscosity index = 31
* Crude stock 3: Octane rating = 90, Viscosity index = 36

The crude stocks are combined to create a blend. The octane rating and viscosity index of the blend is calculated by taking the average per gallon octane rating and viscosity index.  For example, if DP chooses to use 1000 gallons of each stock, the octane rating would be

$\frac{80 \cdot 1000 + 85 \cdot 1000 + 90 \cdot 1000}{3000} = 85$

and the viscocity index would be

$\frac{30 \cdot 1000 + 31 \cdot 1000 + 36 \cdot 1000}{3000} = 32$.

Per day, DP is only able to use 2000 gallons of each of the crude stocks, and each gallon costs:

* Crude stock 1: \$1.10
* Crude stock 2: \$1.40
* Crude stock 3: \$1.60

Find the minimum cost combination of crude stocks to create 3000 gallons of blend, satisfying the octance rating and viscosity index constraints.

** Variables **

* $X$: number of stock 1 gallons
* $Y$: number of stock 2 gallons
* $Z$: number of stock 3 gallons

** Objective **

$1.10 \cdot X + 1.40 \cdot Y + 1.60 \cdot Z$

** Constraints **
"""

best_objective_so_far = 9999999
best_x = 0
best_y = 0
best_z = 0

for x in range(0,2001,10):
  for y in range(0,2001,10):
    for z in range(0,2001,10):
      proposed_solution = np.array([x,y,z])
      # constraint of exactly 3000 gallons combined between each stock
      if proposed_solution[0] + proposed_solution[1] + proposed_solution[2] != 3000:
        continue
      # octane constraint
      if (((proposed_solution[0] * 80) + (proposed_solution[1] * 85) + (proposed_solution[2] * 90)) / 3000) < 87:
        continue
      # viscosity constraint
      if (((proposed_solution[0] * 30) + (proposed_solution[1] * 31) + (proposed_solution[2] * 36)) / 3000) < 31.5:
        continue
      #objective
      candidate_combo = 1.1*x + 1.4*y + 1.6*z
      if candidate_combo < best_objective_so_far:
        best_objective_so_far = candidate_combo
        best_x = x
        best_y = y
        best_z = z

print(best_x)
print(best_y)
print(best_z)
print(best_objective_so_far)

"""# Problem 4

Continuing problem 3, suppose that the price for each crude stock is uncertain:

* Crude stock 1: \$1.10 plus/minus 12\%
* Crude stock 2: \$1.40 plus/minus 15\%
* Crude stock 3: \$1.60 plus/minus 20\%

What is the blend that minimizes expected cost, while satisfying the necessary constraints on octane rating and vicosity index? What about if we want to minimize the 75th quantile?

Create a histogram of the costs from the solution to Problem 3, and the solutions minimizing expected costs and 75th quantile of cost.  Which solution would you recommend to DP and why?
"""

# What is the blend that minimizes expected cost, while satisfying the necessary constraints on octane rating and vicosity index?

best_objective_so_far = 9999999
best_x = 0
best_y = 0
best_z = 0

for x in range(0,2001,10):
  for y in range(0,2001,10):
    for z in range(0,2001,10):
      proposed_solution = np.array([x,y,z])
      # constraint of exactly 3000 gallons combined between each stock
      if proposed_solution[0] + proposed_solution[1] + proposed_solution[2] != 3000:
        continue
      # octane constraint
      if (((proposed_solution[0] * 80) + (proposed_solution[1] * 85) + (proposed_solution[2] * 90)) / 3000) < 87:
        continue
      # viscosity constraint
      if (((proposed_solution[0] * 30) + (proposed_solution[1] * 31) + (proposed_solution[2] * 36)) / 3000) < 31.5:
        continue

      generated_costs = []
      n_simulations = 1000
      for sim_index in range(n_simulations):
       cost_of_x = np.random.uniform(1-0.12,1+0.12) * 1.1 * x
       cost_of_y = np.random.uniform(1-0.15,1+0.15) * 1.4 * y
       cost_of_z = np.random.uniform(1-0.20,1+0.20) * 1.6 * z
       total_cost = cost_of_x + cost_of_y + cost_of_z
       generated_costs.append(total_cost)

      random_mean_cost = np.mean(generated_costs)

      if random_mean_cost < best_objective_so_far:
        best_objective_so_far = random_mean_cost
        best_x = x
        best_y = y
        best_z = z

print(best_x)
print(best_y)
print(best_z)
print(best_objective_so_far)

# What about if we want to minimize the 75th quantile?
best_objective_so_far = 9999999
best_x = 0
best_y = 0
best_z = 0

for x in range(0,2001,10):
  for y in range(0,2001,10):
    for z in range(0,2001,10):
      proposed_solution = np.array([x,y,z])
      # constraint of exactly 3000 gallons combined between each stock
      if proposed_solution[0] + proposed_solution[1] + proposed_solution[2] != 3000:
        continue
      # octane constraint
      if (((proposed_solution[0] * 80) + (proposed_solution[1] * 85) + (proposed_solution[2] * 90)) / 3000) < 87:
        continue
      # viscosity constraint
      if (((proposed_solution[0] * 30) + (proposed_solution[1] * 31) + (proposed_solution[2] * 36)) / 3000) < 31.5:
        continue

      generated_costs = []
      n_simulations = 1000
      for sim_index in range(n_simulations):
       cost_of_x = np.random.uniform(1-0.12,1+0.12) * 1.1 * x
       cost_of_y = np.random.uniform(1-0.15,1+0.15) * 1.4 * y
       cost_of_z = np.random.uniform(1-0.20,1+0.20) * 1.6 * z
       total_cost = cost_of_x + cost_of_y + cost_of_z
       generated_costs.append(total_cost)

      if np.quantile(generated_costs,0.75) < best_objective_so_far:
        best_x = x
        best_y = y
        best_z = z
        best_objective_so_far = np.quantile(generated_costs,0.75)

print(best_x)
print(best_y)
print(best_z)
print(best_objective_so_far)

# Histogram of the costs from the solution to Problem 3
generated_costs = []
n_simulations = 1000
for sim_index in range(n_simulations):
  cost_of_x = np.random.uniform(1-0.12,1+0.12) * 1.1 * 800
  cost_of_y = np.random.uniform(1-0.15,1+0.15) * 1.4 * 200
  cost_of_z = np.random.uniform(1-0.20,1+0.20) * 1.6 * 2000
  total_cost = cost_of_x + cost_of_y + cost_of_z
  generated_costs.append(total_cost)

plt.hist(generated_costs)

# Histogram of the solutions minimizing expected costs
generated_costs = []
n_simulations = 1000
for sim_index in range(n_simulations):
  cost_of_x = np.random.uniform(1-0.12,1+0.12) * 1.1 * 780
  cost_of_y = np.random.uniform(1-0.15,1+0.15) * 1.4 * 240
  cost_of_z = np.random.uniform(1-0.20,1+0.20) * 1.6 * 1980
  total_cost = cost_of_x + cost_of_y + cost_of_z
  generated_costs.append(total_cost)

plt.hist(generated_costs)

# Histogram of the 75th quantile of cost
generated_costs = []
n_simulations = 1000
for sim_index in range(n_simulations):
  cost_of_x = np.random.uniform(1-0.12,1+0.12) * 1.1 * 240
  cost_of_y = np.random.uniform(1-0.15,1+0.15) * 1.4 * 1320
  cost_of_z = np.random.uniform(1-0.20,1+0.20) * 1.6 * 1440
  total_cost = cost_of_x + cost_of_y + cost_of_z
  generated_costs.append(total_cost)

plt.hist(generated_costs)

# Which solution would you recommend to DP and why?

# I recommend the solution minimizing expected costs (780, 240, 1980) because  it satisfies all constraints while also costing the least amount.

